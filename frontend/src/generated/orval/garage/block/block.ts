/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Garage administration API
 * Administrate your Garage cluster programatically, including status, layout, keys, buckets, and maintainance tasks.

*Disclaimer: This API may change in future Garage versions. Read the changelog and upgrade your scripts before upgrading. Additionnaly, this specification is early stage and can contain bugs, so be careful and please report any issues on our issue tracker.*
 * OpenAPI spec version: v2.0.0
 */

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'
import type { ErrorType } from '../../../../axios-instance'

import { customInstance } from '../../../../axios-instance'
import type {
  LocalGetBlockInfoRequest,
  LocalPurgeBlocksRequest,
  LocalRetryBlockResyncRequest,
  MultiResponseLocalGetBlockInfoResponse,
  MultiResponseLocalListBlockErrorsResponse,
  MultiResponseLocalPurgeBlocksResponse,
  MultiResponseLocalRetryBlockResyncResponse,
} from '../endpoints.schemas'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * 
Get detailed information about a data block stored on a Garage node, including all object versions and in-progress multipart uploads that contain a reference to this block.
    
 */
export const getBlockInfo = (
  localGetBlockInfoRequest: LocalGetBlockInfoRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MultiResponseLocalGetBlockInfoResponse>(
    {
      url: `/proxy/v2/GetBlockInfo`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: localGetBlockInfoRequest,
      signal,
    },
    options,
  )
}

export const getGetBlockInfoMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getBlockInfo>>,
    TError,
    { data: LocalGetBlockInfoRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof getBlockInfo>>,
  TError,
  { data: LocalGetBlockInfoRequest },
  TContext
> => {
  const mutationKey = ['getBlockInfo']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getBlockInfo>>,
    { data: LocalGetBlockInfoRequest }
  > = (props) => {
    const { data } = props ?? {}

    return getBlockInfo(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type GetBlockInfoMutationResult = NonNullable<
  Awaited<ReturnType<typeof getBlockInfo>>
>
export type GetBlockInfoMutationBody = LocalGetBlockInfoRequest
export type GetBlockInfoMutationError = ErrorType<void>

export const useGetBlockInfo = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof getBlockInfo>>,
      TError,
      { data: LocalGetBlockInfoRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof getBlockInfo>>,
  TError,
  { data: LocalGetBlockInfoRequest },
  TContext
> => {
  const mutationOptions = getGetBlockInfoMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * 
List data blocks that are currently in an errored state on one or several Garage nodes.
    
 */
export const listBlockErrors = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MultiResponseLocalListBlockErrorsResponse>(
    { url: `/proxy/v2/ListBlockErrors`, method: 'GET', signal },
    options,
  )
}

export const getListBlockErrorsQueryKey = () => {
  return [`/proxy/v2/ListBlockErrors`] as const
}

export const getListBlockErrorsQueryOptions = <
  TData = Awaited<ReturnType<typeof listBlockErrors>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listBlockErrors>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListBlockErrorsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listBlockErrors>>> = ({
    signal,
  }) => listBlockErrors(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listBlockErrors>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBlockErrorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listBlockErrors>>
>
export type ListBlockErrorsQueryError = ErrorType<void>

export function useListBlockErrors<
  TData = Awaited<ReturnType<typeof listBlockErrors>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listBlockErrors>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBlockErrors>>,
          TError,
          Awaited<ReturnType<typeof listBlockErrors>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListBlockErrors<
  TData = Awaited<ReturnType<typeof listBlockErrors>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listBlockErrors>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBlockErrors>>,
          TError,
          Awaited<ReturnType<typeof listBlockErrors>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListBlockErrors<
  TData = Awaited<ReturnType<typeof listBlockErrors>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listBlockErrors>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useListBlockErrors<
  TData = Awaited<ReturnType<typeof listBlockErrors>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listBlockErrors>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListBlockErrorsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * 
Purge references to one or several missing data blocks.

This will remove all objects and in-progress multipart uploads that contain the specified data block(s). The objects will be permanently deleted from the buckets in which they appear. Use with caution.
    
 */
export const purgeBlocks = (
  localPurgeBlocksRequest: LocalPurgeBlocksRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MultiResponseLocalPurgeBlocksResponse>(
    {
      url: `/proxy/v2/PurgeBlocks`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: localPurgeBlocksRequest,
      signal,
    },
    options,
  )
}

export const getPurgeBlocksMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof purgeBlocks>>,
    TError,
    { data: LocalPurgeBlocksRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof purgeBlocks>>,
  TError,
  { data: LocalPurgeBlocksRequest },
  TContext
> => {
  const mutationKey = ['purgeBlocks']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof purgeBlocks>>,
    { data: LocalPurgeBlocksRequest }
  > = (props) => {
    const { data } = props ?? {}

    return purgeBlocks(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type PurgeBlocksMutationResult = NonNullable<
  Awaited<ReturnType<typeof purgeBlocks>>
>
export type PurgeBlocksMutationBody = LocalPurgeBlocksRequest
export type PurgeBlocksMutationError = ErrorType<void>

export const usePurgeBlocks = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof purgeBlocks>>,
      TError,
      { data: LocalPurgeBlocksRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof purgeBlocks>>,
  TError,
  { data: LocalPurgeBlocksRequest },
  TContext
> => {
  const mutationOptions = getPurgeBlocksMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * 
Instruct Garage node(s) to retry the resynchronization of one or several missing data block(s).
    
 */
export const retryBlockResync = (
  localRetryBlockResyncRequest: LocalRetryBlockResyncRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MultiResponseLocalRetryBlockResyncResponse>(
    {
      url: `/proxy/v2/RetryBlockResync`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: localRetryBlockResyncRequest,
      signal,
    },
    options,
  )
}

export const getRetryBlockResyncMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof retryBlockResync>>,
    TError,
    { data: LocalRetryBlockResyncRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof retryBlockResync>>,
  TError,
  { data: LocalRetryBlockResyncRequest },
  TContext
> => {
  const mutationKey = ['retryBlockResync']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof retryBlockResync>>,
    { data: LocalRetryBlockResyncRequest }
  > = (props) => {
    const { data } = props ?? {}

    return retryBlockResync(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RetryBlockResyncMutationResult = NonNullable<
  Awaited<ReturnType<typeof retryBlockResync>>
>
export type RetryBlockResyncMutationBody = LocalRetryBlockResyncRequest
export type RetryBlockResyncMutationError = ErrorType<void>

export const useRetryBlockResync = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof retryBlockResync>>,
      TError,
      { data: LocalRetryBlockResyncRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof retryBlockResync>>,
  TError,
  { data: LocalRetryBlockResyncRequest },
  TContext
> => {
  const mutationOptions = getRetryBlockResyncMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
