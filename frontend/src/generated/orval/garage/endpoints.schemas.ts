/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Garage administration API
 * Administrate your Garage cluster programatically, including status, layout, keys, buckets, and maintainance tasks.

*Disclaimer: This API may change in future Garage versions. Read the changelog and upgrade your scripts before upgrading. Additionnaly, this specification is early stage and can contain bugs, so be careful and please report any issues on our issue tracker.*
 * OpenAPI spec version: v2.0.0
 */
export type AddBucketAliasRequestAllOf = {
  bucketId: string
}

export type AddBucketAliasRequest = BucketAliasEnum & AddBucketAliasRequestAllOf

export type AddBucketAliasResponse = GetBucketInfoResponse

export type AllowBucketKeyRequest = BucketKeyPermChangeRequest

export type AllowBucketKeyResponse = GetBucketInfoResponse

export interface ApiBucketKeyPerm {
  owner?: boolean
  read?: boolean
  write?: boolean
}

/**
 * @minimum 0
 */
export type ApiBucketQuotasMaxObjects = number | null

/**
 * @minimum 0
 */
export type ApiBucketQuotasMaxSize = number | null

export interface ApiBucketQuotas {
  /** @minimum 0 */
  maxObjects?: ApiBucketQuotasMaxObjects
  /** @minimum 0 */
  maxSize?: ApiBucketQuotasMaxSize
}

export interface ApplyClusterLayoutRequest {
  /**
   * As a safety measure, the new version number of the layout must
be specified here
   * @minimum 0
   */
  version: number
}

export interface ApplyClusterLayoutResponse {
  /** Details about the new cluster layout */
  layout: GetClusterLayoutResponse
  /** Plain-text information about the layout computation
(do not try to parse this) */
  message: string[]
}

export interface BlockError {
  blockHash: string
  /** @minimum 0 */
  errorCount: number
  /** @minimum 0 */
  lastTrySecsAgo: number
  /** @minimum 0 */
  nextTryInSecs: number
  /** @minimum 0 */
  refcount: number
}

export type BlockVersionBacklinkProperty = null | BlockVersionBacklink

export interface BlockVersion {
  backlink?: BlockVersionBacklinkProperty
  garbageCollected: boolean
  refDeleted: boolean
  versionDeleted: boolean
  versionId: string
}

export type BlockVersionBacklinkOneOfObject = {
  bucketId: string
  key: string
}

export type BlockVersionBacklinkOneOf = {
  object: BlockVersionBacklinkOneOfObject
}

export type BlockVersionBacklinkOneOfThreeUploadBucketId = string | null

export type BlockVersionBacklinkOneOfThreeUploadKey = string | null

export type BlockVersionBacklinkOneOfThreeUpload = {
  bucketId?: BlockVersionBacklinkOneOfThreeUploadBucketId
  key?: BlockVersionBacklinkOneOfThreeUploadKey
  uploadDeleted: boolean
  uploadGarbageCollected: boolean
  uploadId: string
}

export type BlockVersionBacklinkOneOfThree = {
  upload: BlockVersionBacklinkOneOfThreeUpload
}

export type BlockVersionBacklink =
  | BlockVersionBacklinkOneOf
  | BlockVersionBacklinkOneOfThree

export type BucketAliasEnumOneOf = {
  globalAlias: string
}

export type BucketAliasEnumOneOfTwo = {
  accessKeyId: string
  localAlias: string
}

export type BucketAliasEnum = BucketAliasEnumOneOf | BucketAliasEnumOneOfTwo

export interface BucketKeyPermChangeRequest {
  accessKeyId: string
  bucketId: string
  permissions: ApiBucketKeyPerm
}

export interface BucketLocalAlias {
  accessKeyId: string
  alias: string
}

export interface CleanupIncompleteUploadsRequest {
  bucketId: string
  /** @minimum 0 */
  olderThanSecs: number
}

export interface CleanupIncompleteUploadsResponse {
  /** @minimum 0 */
  uploadsDeleted: number
}

export interface ClusterLayoutSkipDeadNodesRequest {
  /** Allow the skip even if a quorum of nodes could not be found for
the data among the remaining nodes */
  allowMissingData: boolean
  /**
   * Version number of the layout to assume is currently up-to-date.
This will generally be the current layout version.
   * @minimum 0
   */
  version: number
}

export interface ClusterLayoutSkipDeadNodesResponse {
  /** Nodes for which the ACK update tracker has been updated to `version` */
  ackUpdated: string[]
  /** If `allow_missing_data` is set,
nodes for which the SYNC update tracker has been updated to `version` */
  syncUpdated: string[]
}

export interface ClusterLayoutVersion {
  /**
   * Number of nodes with a gateway role in this layout version
   * @minimum 0
   */
  gatewayNodes: number
  /** Status of this layout version */
  status: ClusterLayoutVersionStatus
  /**
   * Number of nodes with an assigned storage capacity in this layout version
   * @minimum 0
   */
  storageNodes: number
  /**
   * Version number of this layout version
   * @minimum 0
   */
  version: number
}

export type ClusterLayoutVersionStatus =
  (typeof ClusterLayoutVersionStatus)[keyof typeof ClusterLayoutVersionStatus]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ClusterLayoutVersionStatus = {
  Current: 'Current',
  Draining: 'Draining',
  Historical: 'Historical',
} as const

export type ConnectClusterNodesRequest = string[]

export type ConnectClusterNodesResponse = ConnectNodeResponse[]

/**
 * An error message if Garage did not manage to connect to this node
 */
export type ConnectNodeResponseError = string | null

export interface ConnectNodeResponse {
  /** An error message if Garage did not manage to connect to this node */
  error?: ConnectNodeResponseError
  /** `true` if Garage managed to connect to this node */
  success: boolean
}

export type CreateAdminTokenResponseAllOf = {
  /** The secret bearer token. **CAUTION:** This token will be shown only
ONCE, so this value MUST be remembered somewhere, or the token
will be unusable. */
  secretToken: string
}

export type CreateAdminTokenResponse = GetAdminTokenInfoResponse &
  CreateAdminTokenResponseAllOf

export interface CreateBucketLocalAlias {
  accessKeyId: string
  alias: string
  allow?: ApiBucketKeyPerm
}

export type CreateBucketRequestGlobalAlias = string | null

export type CreateBucketRequestLocalAlias = null | CreateBucketLocalAlias

export interface CreateBucketRequest {
  globalAlias?: CreateBucketRequestGlobalAlias
  localAlias?: CreateBucketRequestLocalAlias
}

export type CreateBucketResponse = GetBucketInfoResponse

export type CreateKeyRequest = UpdateKeyRequestBody

export type CreateKeyResponse = GetKeyInfoResponse

export type DenyBucketKeyRequest = BucketKeyPermChangeRequest

export type DenyBucketKeyResponse = GetBucketInfoResponse

export interface FreeSpaceResp {
  /**
   * Number of bytes available
   * @minimum 0
   */
  available: number
  /**
   * Total number of bytes
   * @minimum 0
   */
  total: number
}

/**
 * Creation date
 */
export type GetAdminTokenInfoResponseCreated = string | null

/**
 * Expiration time and date, formatted according to RFC 3339
 */
export type GetAdminTokenInfoResponseExpiration = string | null

/**
 * Identifier of the admin token (which is also a prefix of the full bearer token)
 */
export type GetAdminTokenInfoResponseId = string | null

export interface GetAdminTokenInfoResponse {
  /** Creation date */
  created?: GetAdminTokenInfoResponseCreated
  /** Expiration time and date, formatted according to RFC 3339 */
  expiration?: GetAdminTokenInfoResponseExpiration
  /** Whether this admin token is expired already */
  expired: boolean
  /** Identifier of the admin token (which is also a prefix of the full bearer token) */
  id?: GetAdminTokenInfoResponseId
  /** Name of the admin API token */
  name: string
  /** Scope of the admin API token, a list of admin endpoint names (such as
`GetClusterStatus`, etc), or the special value `*` to allow all
admin endpoints */
  scope: string[]
}

export interface GetBucketInfoKey {
  accessKeyId: string
  bucketLocalAliases: string[]
  name: string
  permissions: ApiBucketKeyPerm
}

export type GetBucketInfoResponseWebsiteConfig =
  null | GetBucketInfoWebsiteResponse

export interface GetBucketInfoResponse {
  /** Total number of bytes used by objects in this bucket */
  bytes: number
  /** Bucket creation date */
  created: string
  /** List of global aliases for this bucket */
  globalAliases: string[]
  /** Identifier of the bucket */
  id: string
  /** List of access keys that have permissions granted on this bucket */
  keys: GetBucketInfoKey[]
  /** Number of objects in this bucket */
  objects: number
  /** Quotas that apply to this bucket */
  quotas: ApiBucketQuotas
  /** Total number of bytes used by unfinished multipart uploads in this bucket */
  unfinishedMultipartUploadBytes: number
  /** Number of parts in unfinished multipart uploads in this bucket */
  unfinishedMultipartUploadParts: number
  /** Number of unfinished multipart uploads in this bucket */
  unfinishedMultipartUploads: number
  /** Number of unfinished uploads in this bucket */
  unfinishedUploads: number
  /** Whether website acces is enabled for this bucket */
  websiteAccess: boolean
  websiteConfig?: GetBucketInfoResponseWebsiteConfig
}

export type GetBucketInfoWebsiteResponseErrorDocument = string | null

export interface GetBucketInfoWebsiteResponse {
  errorDocument?: GetBucketInfoWebsiteResponseErrorDocument
  indexDocument: string
}

export interface GetClusterHealthResponse {
  /**
   * the nubmer of nodes this Garage node currently has an open connection to
   * @minimum 0
   */
  connectedNodes: number
  /**
   * the number of nodes this Garage node has had a TCP connection to since the daemon started
   * @minimum 0
   */
  knownNodes: number
  /**
   * the total number of partitions of the data (currently always 256)
   * @minimum 0
   */
  partitions: number
  /**
   * the number of partitions for which we are connected to all storage nodes responsible of storing it
   * @minimum 0
   */
  partitionsAllOk: number
  /**
   * the number of partitions for which a quorum of write nodes is available
   * @minimum 0
   */
  partitionsQuorum: number
  /** One of `healthy`, `degraded` or `unavailable`:
- `healthy`: Garage node is connected to all storage nodes
- `degraded`: Garage node is not connected to all storage nodes, but a quorum of write nodes is available for all partitions
- `unavailable`: a quorum of write nodes is not available for some partitions */
  status: string
  /**
   * the number of storage nodes currently registered in the cluster layout
   * @minimum 0
   */
  storageNodes: number
  /**
   * the number of storage nodes to which a connection is currently open
   * @minimum 0
   */
  storageNodesOk: number
}

/**
 * Detailed update trackers for nodes (see
`https://garagehq.deuxfleurs.fr/blog/2023-12-preserving-read-after-write-consistency/`)
 */
export type GetClusterLayoutHistoryResponseUpdateTrackersAnyOf = {
  [key: string]: NodeUpdateTrackers
}

/**
 * Detailed update trackers for nodes (see
`https://garagehq.deuxfleurs.fr/blog/2023-12-preserving-read-after-write-consistency/`)
 */
export type GetClusterLayoutHistoryResponseUpdateTrackers =
  GetClusterLayoutHistoryResponseUpdateTrackersAnyOf | null

export interface GetClusterLayoutHistoryResponse {
  /**
   * The current version number of the cluster layout
   * @minimum 0
   */
  currentVersion: number
  /**
   * All nodes in the cluster are aware of layout versions up to
this version number (at least)
   * @minimum 0
   */
  minAck: number
  /** Detailed update trackers for nodes (see
`https://garagehq.deuxfleurs.fr/blog/2023-12-preserving-read-after-write-consistency/`) */
  updateTrackers?: GetClusterLayoutHistoryResponseUpdateTrackers
  /** Layout version history */
  versions: ClusterLayoutVersion[]
}

export type GetClusterLayoutResponseStagedParameters = null | LayoutParameters

export interface GetClusterLayoutResponse {
  /** Layout parameters used when the current layout was computed */
  parameters: LayoutParameters
  /**
   * The size, in bytes, of one Garage partition (= a shard)
   * @minimum 0
   */
  partitionSize: number
  /** List of nodes that currently have a role in the cluster layout */
  roles: LayoutNodeRole[]
  stagedParameters?: GetClusterLayoutResponseStagedParameters
  /** List of nodes that will have a new role or whose role will be
removed in the next version of the cluster layout */
  stagedRoleChanges: NodeRoleChange[]
  /**
   * The current version number of the cluster layout
   * @minimum 0
   */
  version: number
}

export interface GetClusterStatisticsResponse {
  freeform: string
}

export interface GetClusterStatusResponse {
  /**
   * Current version number of the cluster layout
   * @minimum 0
   */
  layoutVersion: number
  /** List of nodes that are either currently connected, part of the
current cluster layout, or part of an older cluster layout that
is still active in the cluster (being drained). */
  nodes: NodeResp[]
}

export type GetKeyInfoResponseCreated = string | null

export type GetKeyInfoResponseExpiration = string | null

export type GetKeyInfoResponseSecretAccessKey = string | null

export interface GetKeyInfoResponse {
  accessKeyId: string
  buckets: KeyInfoBucketResponse[]
  created?: GetKeyInfoResponseCreated
  expiration?: GetKeyInfoResponseExpiration
  expired: boolean
  name: string
  permissions: KeyPerm
  secretAccessKey?: GetKeyInfoResponseSecretAccessKey
}

export type ImportKeyRequestName = string | null

export interface ImportKeyRequest {
  accessKeyId: string
  name?: ImportKeyRequestName
  secretAccessKey: string
}

export type ImportKeyResponse = GetKeyInfoResponse

export interface InspectObjectBlock {
  /** Hash (blake2 sum) of the block's data */
  hash: string
  /**
   * Offset of this block within the part
   * @minimum 0
   */
  offset: number
  /**
   * Part number of the part containing this block, for multipart uploads
   * @minimum 0
   */
  partNumber: number
  /**
   * Length of the blocks's data
   * @minimum 0
   */
  size: number
}

export interface InspectObjectResponse {
  /** ID of the bucket containing the inspected object */
  bucketId: string
  /** Key of the inspected object */
  key: string
  /** List of versions currently stored for this object */
  versions: InspectObjectVersion[]
}

/**
 * Etag of this object version
 */
export type InspectObjectVersionEtag = string | null

/**
 * Size of the object, in bytes
 * @minimum 0
 */
export type InspectObjectVersionSize = number | null

export interface InspectObjectVersion {
  /** Whether this is an aborted upload */
  aborted: boolean
  /** List of data blocks for this object version */
  blocks?: InspectObjectBlock[]
  /** Whether this version is a delete marker (a tombstone indicating that a previous version of
the object has been deleted) */
  deleteMarker: boolean
  /** Whether this object version was created with SSE-C encryption */
  encrypted: boolean
  /** Etag of this object version */
  etag?: InspectObjectVersionEtag
  /** Metadata (HTTP headers) associated with this object version */
  headers?: [string, string][]
  /** Whether the object's data is stored inline (for small objects) */
  inline: boolean
  /**
   * Size of the object, in bytes
   * @minimum 0
   */
  size?: InspectObjectVersionSize
  /** Creation timestamp of this object version */
  timestamp: string
  /** Whether this object version is still uploading */
  uploading: boolean
  /** Version ID */
  uuid: string
}

export interface KeyInfoBucketResponse {
  globalAliases: string[]
  id: string
  localAliases: string[]
  permissions: ApiBucketKeyPerm
}

export interface KeyPerm {
  createBucket?: boolean
}

/**
 * Capacity (in bytes) assigned by the cluster administrator,
absent for gateway nodes
 * @minimum 0
 */
export type LayoutNodeRoleCapacity = number | null

/**
 * Number of partitions stored on this node
(a result of the layout computation)
 * @minimum 0
 */
export type LayoutNodeRoleStoredPartitions = number | null

/**
 * Capacity (in bytes) that is actually usable on this node in the current
layout, which is equal to `stored_partitions` √ó `partition_size`
 * @minimum 0
 */
export type LayoutNodeRoleUsableCapacity = number | null

export interface LayoutNodeRole {
  /**
   * Capacity (in bytes) assigned by the cluster administrator,
absent for gateway nodes
   * @minimum 0
   */
  capacity?: LayoutNodeRoleCapacity
  /** Identifier of the node */
  id: string
  /**
   * Number of partitions stored on this node
(a result of the layout computation)
   * @minimum 0
   */
  storedPartitions?: LayoutNodeRoleStoredPartitions
  /** List of tags assigned by the cluster administrator */
  tags: string[]
  /**
   * Capacity (in bytes) that is actually usable on this node in the current
layout, which is equal to `stored_partitions` √ó `partition_size`
   * @minimum 0
   */
  usableCapacity?: LayoutNodeRoleUsableCapacity
  /** Zone name assigned by the cluster administrator */
  zone: string
}

export interface LayoutParameters {
  /** Minimum number of zones in which a data partition must be replicated */
  zoneRedundancy: ZoneRedundancy
}

export type ListAdminTokensResponse = GetAdminTokenInfoResponse[]

export type ListBucketsResponse = ListBucketsResponseItem[]

export interface ListBucketsResponseItem {
  created: string
  globalAliases: string[]
  id: string
  localAliases: BucketLocalAlias[]
}

export type ListKeysResponse = ListKeysResponseItem[]

export type ListKeysResponseItemCreated = string | null

export type ListKeysResponseItemExpiration = string | null

export interface ListKeysResponseItem {
  created?: ListKeysResponseItemCreated
  expiration?: ListKeysResponseItemExpiration
  expired: boolean
  id: string
  name: string
}

export type LocalCreateMetadataSnapshotResponse = {}

export interface LocalGetBlockInfoRequest {
  blockHash: string
}

export interface LocalGetBlockInfoResponse {
  blockHash: string
  /** @minimum 0 */
  refcount: number
  versions: BlockVersion[]
}

export type LocalGetNodeInfoResponseGarageFeatures = string[] | null

export interface LocalGetNodeInfoResponse {
  dbEngine: string
  garageFeatures?: LocalGetNodeInfoResponseGarageFeatures
  garageVersion: string
  nodeId: string
  rustVersion: string
}

export interface LocalGetNodeStatisticsResponse {
  freeform: string
}

export interface LocalGetWorkerInfoRequest {
  /** @minimum 0 */
  id: number
}

export type LocalGetWorkerInfoResponse = WorkerInfoResp

export type LocalGetWorkerVariableRequestVariable = string | null

export interface LocalGetWorkerVariableRequest {
  variable?: LocalGetWorkerVariableRequestVariable
}

export interface LocalGetWorkerVariableResponse {
  [key: string]: string
}

export interface LocalLaunchRepairOperationRequest {
  repairType: RepairType
}

export type LocalLaunchRepairOperationResponse = {}

export type LocalListBlockErrorsResponse = BlockError[]

export interface LocalListWorkersRequest {
  busyOnly?: boolean
  errorOnly?: boolean
}

export type LocalListWorkersResponse = WorkerInfoResp[]

export type LocalPurgeBlocksRequest = string[]

export interface LocalPurgeBlocksResponse {
  /** @minimum 0 */
  blockRefsPurged: number
  /** @minimum 0 */
  blocksPurged: number
  /** @minimum 0 */
  objectsDeleted: number
  /** @minimum 0 */
  uploadsDeleted: number
  /** @minimum 0 */
  versionsDeleted: number
}

export type LocalRetryBlockResyncRequestOneOf = {
  all: boolean
}

export type LocalRetryBlockResyncRequestOneOfTwo = {
  blockHashes: string[]
}

export type LocalRetryBlockResyncRequest =
  | LocalRetryBlockResyncRequestOneOf
  | LocalRetryBlockResyncRequestOneOfTwo

export interface LocalRetryBlockResyncResponse {
  /** @minimum 0 */
  count: number
}

export interface LocalSetWorkerVariableRequest {
  value: string
  variable: string
}

export interface LocalSetWorkerVariableResponse {
  value: string
  variable: string
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalCreateMetadataSnapshotResponseError = {
  [key: string]: string
}

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalCreateMetadataSnapshotResponseSuccess = {
  [key: string]: unknown
}

export interface MultiResponseLocalCreateMetadataSnapshotResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalCreateMetadataSnapshotResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalCreateMetadataSnapshotResponseSuccess
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalGetBlockInfoResponseError = {
  [key: string]: string
}

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalGetBlockInfoResponseSuccess = {
  [key: string]: {
    blockHash: string
    /** @minimum 0 */
    refcount: number
    versions: BlockVersion[]
  }
}

export interface MultiResponseLocalGetBlockInfoResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalGetBlockInfoResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalGetBlockInfoResponseSuccess
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalGetNodeInfoResponseError = {
  [key: string]: string
}

export type MultiResponseLocalGetNodeInfoResponseSuccessGarageFeatures =
  | string[]
  | null

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalGetNodeInfoResponseSuccess = {
  [key: string]: {
    dbEngine: string
    garageFeatures?: MultiResponseLocalGetNodeInfoResponseSuccessGarageFeatures
    garageVersion: string
    nodeId: string
    rustVersion: string
  }
}

export interface MultiResponseLocalGetNodeInfoResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalGetNodeInfoResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalGetNodeInfoResponseSuccess
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalGetNodeStatisticsResponseError = {
  [key: string]: string
}

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalGetNodeStatisticsResponseSuccess = {
  [key: string]: {
    freeform: string
  }
}

export interface MultiResponseLocalGetNodeStatisticsResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalGetNodeStatisticsResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalGetNodeStatisticsResponseSuccess
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalGetWorkerInfoResponseError = {
  [key: string]: string
}

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalGetWorkerInfoResponseSuccess = {
  [key: string]: WorkerInfoResp
}

export interface MultiResponseLocalGetWorkerInfoResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalGetWorkerInfoResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalGetWorkerInfoResponseSuccess
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalGetWorkerVariableResponseError = {
  [key: string]: string
}

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalGetWorkerVariableResponseSuccess = {
  [key: string]: { [key: string]: string }
}

export interface MultiResponseLocalGetWorkerVariableResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalGetWorkerVariableResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalGetWorkerVariableResponseSuccess
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalLaunchRepairOperationResponseError = {
  [key: string]: string
}

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalLaunchRepairOperationResponseSuccess = {
  [key: string]: unknown
}

export interface MultiResponseLocalLaunchRepairOperationResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalLaunchRepairOperationResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalLaunchRepairOperationResponseSuccess
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalListBlockErrorsResponseError = {
  [key: string]: string
}

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalListBlockErrorsResponseSuccess = {
  [key: string]: BlockError[]
}

export interface MultiResponseLocalListBlockErrorsResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalListBlockErrorsResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalListBlockErrorsResponseSuccess
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalListWorkersResponseError = {
  [key: string]: string
}

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalListWorkersResponseSuccess = {
  [key: string]: WorkerInfoResp[]
}

export interface MultiResponseLocalListWorkersResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalListWorkersResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalListWorkersResponseSuccess
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalPurgeBlocksResponseError = {
  [key: string]: string
}

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalPurgeBlocksResponseSuccess = {
  [key: string]: {
    /** @minimum 0 */
    blockRefsPurged: number
    /** @minimum 0 */
    blocksPurged: number
    /** @minimum 0 */
    objectsDeleted: number
    /** @minimum 0 */
    uploadsDeleted: number
    /** @minimum 0 */
    versionsDeleted: number
  }
}

export interface MultiResponseLocalPurgeBlocksResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalPurgeBlocksResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalPurgeBlocksResponseSuccess
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalRetryBlockResyncResponseError = {
  [key: string]: string
}

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalRetryBlockResyncResponseSuccess = {
  [key: string]: {
    /** @minimum 0 */
    count: number
  }
}

export interface MultiResponseLocalRetryBlockResyncResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalRetryBlockResyncResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalRetryBlockResyncResponseSuccess
}

/**
 * Map of node id to error message, for nodes that were unable to complete the API
call
 */
export type MultiResponseLocalSetWorkerVariableResponseError = {
  [key: string]: string
}

/**
 * Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call
 */
export type MultiResponseLocalSetWorkerVariableResponseSuccess = {
  [key: string]: {
    value: string
    variable: string
  }
}

export interface MultiResponseLocalSetWorkerVariableResponse {
  /** Map of node id to error message, for nodes that were unable to complete the API
call */
  error: MultiResponseLocalSetWorkerVariableResponseError
  /** Map of node id to response returned by this node, for nodes that were able to
successfully complete the API call */
  success: MultiResponseLocalSetWorkerVariableResponseSuccess
}

/**
 * Capacity (in bytes) assigned by the cluster administrator,
absent for gateway nodes
 * @minimum 0
 */
export type NodeAssignedRoleCapacity = number | null

export interface NodeAssignedRole {
  /**
   * Capacity (in bytes) assigned by the cluster administrator,
absent for gateway nodes
   * @minimum 0
   */
  capacity?: NodeAssignedRoleCapacity
  /** List of tags assigned by the cluster administrator */
  tags: string[]
  /** Zone name assigned by the cluster administrator */
  zone: string
}

/**
 * Socket address used by other nodes to connect to this node for RPC
 */
export type NodeRespAddr = string | null

export type NodeRespDataPartition = null | FreeSpaceResp

/**
 * Garage version
 */
export type NodeRespGarageVersion = string | null

/**
 * Hostname of the node
 */
export type NodeRespHostname = string | null

/**
 * For disconnected nodes, the number of seconds since last contact,
or `null` if no contact was established since Garage restarted.
 * @minimum 0
 */
export type NodeRespLastSeenSecsAgo = number | null

export type NodeRespMetadataPartition = null | FreeSpaceResp

export type NodeRespRole = null | NodeAssignedRole

export interface NodeResp {
  /** Socket address used by other nodes to connect to this node for RPC */
  addr?: NodeRespAddr
  dataPartition?: NodeRespDataPartition
  /** Whether this node is part of an older layout version and is draining data. */
  draining: boolean
  /** Garage version */
  garageVersion?: NodeRespGarageVersion
  /** Hostname of the node */
  hostname?: NodeRespHostname
  /** Full-length node identifier */
  id: string
  /** Whether this node is connected in the cluster */
  isUp: boolean
  /**
   * For disconnected nodes, the number of seconds since last contact,
or `null` if no contact was established since Garage restarted.
   * @minimum 0
   */
  lastSeenSecsAgo?: NodeRespLastSeenSecsAgo
  metadataPartition?: NodeRespMetadataPartition
  role?: NodeRespRole
}

export type NodeRoleChangeAllOf = {
  /** ID of the node for which this change applies */
  id: string
}

export type NodeRoleChange = NodeRoleChangeEnum & NodeRoleChangeAllOf

export type NodeRoleChangeEnumOneOf = {
  /** Set `remove` to `true` to remove the node from the layout */
  remove: boolean
}

export type NodeRoleChangeEnum = NodeRoleChangeEnumOneOf | NodeAssignedRole

export interface NodeUpdateTrackers {
  /** @minimum 0 */
  ack: number
  /** @minimum 0 */
  sync: number
  /** @minimum 0 */
  syncAck: number
}

export type PreviewClusterLayoutChangesResponseOneOf = {
  /** Error message indicating that the layout could not be computed
with the provided configuration */
  error: string
}

export type PreviewClusterLayoutChangesResponseOneOfTwo = {
  /** Plain-text information about the layout computation
(do not try to parse this) */
  message: string[]
  /** Details about the new cluster layout */
  newLayout: GetClusterLayoutResponse
}

export type PreviewClusterLayoutChangesResponse =
  | PreviewClusterLayoutChangesResponseOneOf
  | PreviewClusterLayoutChangesResponseOneOfTwo

export type RemoveBucketAliasRequestAllOf = {
  bucketId: string
}

export type RemoveBucketAliasRequest = BucketAliasEnum &
  RemoveBucketAliasRequestAllOf

export type RemoveBucketAliasResponse = GetBucketInfoResponse

export type RepairTypeOneOf = {
  scrub: ScrubCommand
}

export type RepairType =
  | 'tables'
  | 'blocks'
  | 'versions'
  | 'multipartUploads'
  | 'blockRefs'
  | 'blockRc'
  | 'rebalance'
  | RepairTypeOneOf
  | 'aliases'

export type RevertClusterLayoutResponse = GetClusterLayoutResponse

export type ScrubCommand = (typeof ScrubCommand)[keyof typeof ScrubCommand]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ScrubCommand = {
  start: 'start',
  pause: 'pause',
  resume: 'resume',
  cancel: 'cancel',
} as const

/**
 * Expiration time and date, formatted according to RFC 3339
 */
export type UpdateAdminTokenRequestBodyExpiration = string | null

/**
 * Name of the admin API token
 */
export type UpdateAdminTokenRequestBodyName = string | null

/**
 * Scope of the admin API token, a list of admin endpoint names (such as
`GetClusterStatus`, etc), or the special value `*` to allow all
admin endpoints. **WARNING:** Granting a scope of `CreateAdminToken` or
`UpdateAdminToken` trivially allows for privilege escalation, and is thus
functionnally equivalent to granting a scope of `*`.
 */
export type UpdateAdminTokenRequestBodyScope = string[] | null

export interface UpdateAdminTokenRequestBody {
  /** Expiration time and date, formatted according to RFC 3339 */
  expiration?: UpdateAdminTokenRequestBodyExpiration
  /** Name of the admin API token */
  name?: UpdateAdminTokenRequestBodyName
  /** Set the admin token to never expire */
  neverExpires?: boolean
  /** Scope of the admin API token, a list of admin endpoint names (such as
`GetClusterStatus`, etc), or the special value `*` to allow all
admin endpoints. **WARNING:** Granting a scope of `CreateAdminToken` or
`UpdateAdminToken` trivially allows for privilege escalation, and is thus
functionnally equivalent to granting a scope of `*`. */
  scope?: UpdateAdminTokenRequestBodyScope
}

export type UpdateAdminTokenResponse = GetAdminTokenInfoResponse

export type UpdateBucketRequestBodyQuotas = null | ApiBucketQuotas

export type UpdateBucketRequestBodyWebsiteAccess =
  null | UpdateBucketWebsiteAccess

export interface UpdateBucketRequestBody {
  quotas?: UpdateBucketRequestBodyQuotas
  websiteAccess?: UpdateBucketRequestBodyWebsiteAccess
}

export type UpdateBucketResponse = GetBucketInfoResponse

export type UpdateBucketWebsiteAccessErrorDocument = string | null

export type UpdateBucketWebsiteAccessIndexDocument = string | null

export interface UpdateBucketWebsiteAccess {
  enabled: boolean
  errorDocument?: UpdateBucketWebsiteAccessErrorDocument
  indexDocument?: UpdateBucketWebsiteAccessIndexDocument
}

export type UpdateClusterLayoutRequestParameters = null | LayoutParameters

export interface UpdateClusterLayoutRequest {
  parameters?: UpdateClusterLayoutRequestParameters
  /** New node roles to assign or remove in the cluster layout */
  roles?: NodeRoleChange[]
}

export type UpdateClusterLayoutResponse = GetClusterLayoutResponse

export type UpdateKeyRequestBodyAllow = null | KeyPerm

export type UpdateKeyRequestBodyDeny = null | KeyPerm

/**
 * Expiration time and date, formatted according to RFC 3339
 */
export type UpdateKeyRequestBodyExpiration = string | null

/**
 * Name of the API key
 */
export type UpdateKeyRequestBodyName = string | null

export interface UpdateKeyRequestBody {
  allow?: UpdateKeyRequestBodyAllow
  deny?: UpdateKeyRequestBodyDeny
  /** Expiration time and date, formatted according to RFC 3339 */
  expiration?: UpdateKeyRequestBodyExpiration
  /** Name of the API key */
  name?: UpdateKeyRequestBodyName
  /** Set the access key to never expire */
  neverExpires?: boolean
}

export type UpdateKeyResponse = GetKeyInfoResponse

export type WorkerInfoRespLastError = null | WorkerLastError

/**
 * @minimum 0
 */
export type WorkerInfoRespPersistentErrors = number | null

export type WorkerInfoRespProgress = string | null

/**
 * @minimum 0
 */
export type WorkerInfoRespQueueLength = number | null

/**
 * @minimum 0
 */
export type WorkerInfoRespTranquility = number | null

export interface WorkerInfoResp {
  /** @minimum 0 */
  consecutiveErrors: number
  /** @minimum 0 */
  errors: number
  freeform: string[]
  /** @minimum 0 */
  id: number
  lastError?: WorkerInfoRespLastError
  name: string
  /** @minimum 0 */
  persistentErrors?: WorkerInfoRespPersistentErrors
  progress?: WorkerInfoRespProgress
  /** @minimum 0 */
  queueLength?: WorkerInfoRespQueueLength
  state: WorkerStateResp
  /** @minimum 0 */
  tranquility?: WorkerInfoRespTranquility
}

export interface WorkerLastError {
  message: string
  /** @minimum 0 */
  secsAgo: number
}

export type WorkerStateRespOneOfThrottled = {
  durationSecs: number
}

export type WorkerStateRespOneOf = {
  throttled: WorkerStateRespOneOfThrottled
}

export type WorkerStateResp = 'busy' | WorkerStateRespOneOf | 'idle' | 'done'

/**
 * Partitions must be replicated in at least this number of
distinct zones.
 */
export type ZoneRedundancyOneOf = {
  /**
   * Partitions must be replicated in at least this number of
distinct zones.
   * @minimum 0
   */
  atLeast: number
}

export type ZoneRedundancy = ZoneRedundancyOneOf | 'maximum'

export type DeleteAdminTokenParams = {
  /**
   * Admin API token ID
   */
  id: string
}

export type DeleteKeyParams = {
  /**
   * Access key ID
   */
  id: string
}

export type GetAdminTokenInfoParams = {
  /**
   * Admin API token ID
   */
  id?: string
  /**
   * Partial token ID or name to search for
   */
  search?: string
}

export type GetBucketInfoParams = {
  /**
   * Exact bucket ID to look up
   */
  id?: string
  /**
   * Global alias of bucket to look up
   */
  globalAlias?: string
  /**
   * Partial ID or alias to search for
   */
  search?: string
}

export type GetKeyInfoParams = {
  /**
   * Access key ID
   */
  id?: string
  /**
   * Partial key ID or name to search for
   */
  search?: string
  /**
   * Whether to return the secret access key
   */
  showSecretKey?: boolean
}

export type InspectObjectParams = {
  bucketId: string
  key: string
}

export type UpdateBucketParams = {
  /**
   * ID of the bucket to update
   */
  id: string
}
