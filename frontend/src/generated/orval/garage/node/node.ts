/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Garage administration API
 * Administrate your Garage cluster programatically, including status, layout, keys, buckets, and maintainance tasks.

*Disclaimer: This API may change in future Garage versions. Read the changelog and upgrade your scripts before upgrading. Additionnaly, this specification is early stage and can contain bugs, so be careful and please report any issues on our issue tracker.*
 * OpenAPI spec version: v2.0.0
 */

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'
import type { ErrorType } from '../../../../axios-instance'

import { customInstance } from '../../../../axios-instance'
import type {
  LocalLaunchRepairOperationRequest,
  MultiResponseLocalCreateMetadataSnapshotResponse,
  MultiResponseLocalGetNodeInfoResponse,
  MultiResponseLocalGetNodeStatisticsResponse,
  MultiResponseLocalLaunchRepairOperationResponse,
} from '../endpoints.schemas'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * 
Instruct one or several nodes to take a snapshot of their metadata databases.
    
 */
export const createMetadataSnapshot = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MultiResponseLocalCreateMetadataSnapshotResponse>(
    { url: `/proxy/v2/CreateMetadataSnapshot`, method: 'POST', signal },
    options,
  )
}

export const getCreateMetadataSnapshotMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMetadataSnapshot>>,
    TError,
    void,
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMetadataSnapshot>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['createMetadataSnapshot']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMetadataSnapshot>>,
    void
  > = () => {
    return createMetadataSnapshot(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateMetadataSnapshotMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMetadataSnapshot>>
>

export type CreateMetadataSnapshotMutationError = ErrorType<void>

export const useCreateMetadataSnapshot = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createMetadataSnapshot>>,
      TError,
      void,
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createMetadataSnapshot>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getCreateMetadataSnapshotMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * 
Return information about the Garage daemon running on one or several nodes.
    
 */
export const getNodeInfo = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MultiResponseLocalGetNodeInfoResponse>(
    { url: `/proxy/v2/GetNodeInfo`, method: 'GET', signal },
    options,
  )
}

export const getGetNodeInfoQueryKey = () => {
  return [`/proxy/v2/GetNodeInfo`] as const
}

export const getGetNodeInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeInfo>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNodeInfo>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetNodeInfoQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeInfo>>> = ({
    signal,
  }) => getNodeInfo(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNodeInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNodeInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeInfo>>
>
export type GetNodeInfoQueryError = ErrorType<void>

export function useGetNodeInfo<
  TData = Awaited<ReturnType<typeof getNodeInfo>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNodeInfo>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNodeInfo>>,
          TError,
          Awaited<ReturnType<typeof getNodeInfo>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetNodeInfo<
  TData = Awaited<ReturnType<typeof getNodeInfo>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNodeInfo>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNodeInfo>>,
          TError,
          Awaited<ReturnType<typeof getNodeInfo>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetNodeInfo<
  TData = Awaited<ReturnType<typeof getNodeInfo>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNodeInfo>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useGetNodeInfo<
  TData = Awaited<ReturnType<typeof getNodeInfo>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNodeInfo>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetNodeInfoQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * 
Fetch statistics for one or several Garage nodes.

*Note: do not try to parse the `freeform` field of the response, it is given as a string specifically because its format is not stable.*
    
 */
export const getNodeStatistics = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MultiResponseLocalGetNodeStatisticsResponse>(
    { url: `/proxy/v2/GetNodeStatistics`, method: 'GET', signal },
    options,
  )
}

export const getGetNodeStatisticsQueryKey = () => {
  return [`/proxy/v2/GetNodeStatistics`] as const
}

export const getGetNodeStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeStatistics>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNodeStatistics>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetNodeStatisticsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodeStatistics>>
  > = ({ signal }) => getNodeStatistics(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNodeStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNodeStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeStatistics>>
>
export type GetNodeStatisticsQueryError = ErrorType<void>

export function useGetNodeStatistics<
  TData = Awaited<ReturnType<typeof getNodeStatistics>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNodeStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNodeStatistics>>,
          TError,
          Awaited<ReturnType<typeof getNodeStatistics>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetNodeStatistics<
  TData = Awaited<ReturnType<typeof getNodeStatistics>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNodeStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNodeStatistics>>,
          TError,
          Awaited<ReturnType<typeof getNodeStatistics>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetNodeStatistics<
  TData = Awaited<ReturnType<typeof getNodeStatistics>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNodeStatistics>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useGetNodeStatistics<
  TData = Awaited<ReturnType<typeof getNodeStatistics>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNodeStatistics>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetNodeStatisticsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * 
Launch a repair operation on one or several cluster nodes.
    
 */
export const launchRepairOperation = (
  localLaunchRepairOperationRequest: LocalLaunchRepairOperationRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MultiResponseLocalLaunchRepairOperationResponse>(
    {
      url: `/proxy/v2/LaunchRepairOperation`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: localLaunchRepairOperationRequest,
      signal,
    },
    options,
  )
}

export const getLaunchRepairOperationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof launchRepairOperation>>,
    TError,
    { data: LocalLaunchRepairOperationRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof launchRepairOperation>>,
  TError,
  { data: LocalLaunchRepairOperationRequest },
  TContext
> => {
  const mutationKey = ['launchRepairOperation']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof launchRepairOperation>>,
    { data: LocalLaunchRepairOperationRequest }
  > = (props) => {
    const { data } = props ?? {}

    return launchRepairOperation(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LaunchRepairOperationMutationResult = NonNullable<
  Awaited<ReturnType<typeof launchRepairOperation>>
>
export type LaunchRepairOperationMutationBody =
  LocalLaunchRepairOperationRequest
export type LaunchRepairOperationMutationError = ErrorType<void>

export const useLaunchRepairOperation = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof launchRepairOperation>>,
      TError,
      { data: LocalLaunchRepairOperationRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof launchRepairOperation>>,
  TError,
  { data: LocalLaunchRepairOperationRequest },
  TContext
> => {
  const mutationOptions = getLaunchRepairOperationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
