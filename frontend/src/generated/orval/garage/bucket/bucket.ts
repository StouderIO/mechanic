/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * Garage administration API
 * Administrate your Garage cluster programatically, including status, layout, keys, buckets, and maintainance tasks.

*Disclaimer: This API may change in future Garage versions. Read the changelog and upgrade your scripts before upgrading. Additionnaly, this specification is early stage and can contain bugs, so be careful and please report any issues on our issue tracker.*
 * OpenAPI spec version: v2.0.0
 */

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'
import type { ErrorType } from '../../../../axios-instance'

import { customInstance } from '../../../../axios-instance'
import type {
  CleanupIncompleteUploadsRequest,
  CleanupIncompleteUploadsResponse,
  CreateBucketRequest,
  GetBucketInfoParams,
  GetBucketInfoResponse,
  InspectObjectParams,
  InspectObjectResponse,
  ListBucketsResponse,
  UpdateBucketParams,
  UpdateBucketRequestBody,
} from '../endpoints.schemas'

/**
 * Removes all incomplete multipart uploads that are older than the specified number of seconds.
 */
export const cleanupIncompleteUploads = (
  cleanupIncompleteUploadsRequest: CleanupIncompleteUploadsRequest,
  signal?: AbortSignal,
) => {
  return customInstance<CleanupIncompleteUploadsResponse>({
    url: `/proxy/v2/CleanupIncompleteUploads`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: cleanupIncompleteUploadsRequest,
    signal,
  })
}

export const getCleanupIncompleteUploadsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cleanupIncompleteUploads>>,
    TError,
    { data: CleanupIncompleteUploadsRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof cleanupIncompleteUploads>>,
  TError,
  { data: CleanupIncompleteUploadsRequest },
  TContext
> => {
  const mutationKey = ['cleanupIncompleteUploads']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cleanupIncompleteUploads>>,
    { data: CleanupIncompleteUploadsRequest }
  > = (props) => {
    const { data } = props ?? {}

    return cleanupIncompleteUploads(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CleanupIncompleteUploadsMutationResult = NonNullable<
  Awaited<ReturnType<typeof cleanupIncompleteUploads>>
>
export type CleanupIncompleteUploadsMutationBody =
  CleanupIncompleteUploadsRequest
export type CleanupIncompleteUploadsMutationError = ErrorType<void>

export const useCleanupIncompleteUploads = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cleanupIncompleteUploads>>,
      TError,
      { data: CleanupIncompleteUploadsRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof cleanupIncompleteUploads>>,
  TError,
  { data: CleanupIncompleteUploadsRequest },
  TContext
> => {
  const mutationOptions = getCleanupIncompleteUploadsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * 
Creates a new bucket, either with a global alias, a local one, or no alias at all.
Technically, you can also specify both `globalAlias` and `localAlias` and that would create two aliases.
    
 */
export const createBucket = (
  createBucketRequest: CreateBucketRequest,
  signal?: AbortSignal,
) => {
  return customInstance<GetBucketInfoResponse>({
    url: `/proxy/v2/CreateBucket`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createBucketRequest,
    signal,
  })
}

export const getCreateBucketMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createBucket>>,
    TError,
    { data: CreateBucketRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createBucket>>,
  TError,
  { data: CreateBucketRequest },
  TContext
> => {
  const mutationKey = ['createBucket']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createBucket>>,
    { data: CreateBucketRequest }
  > = (props) => {
    const { data } = props ?? {}

    return createBucket(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateBucketMutationResult = NonNullable<
  Awaited<ReturnType<typeof createBucket>>
>
export type CreateBucketMutationBody = CreateBucketRequest
export type CreateBucketMutationError = ErrorType<void>

export const useCreateBucket = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createBucket>>,
      TError,
      { data: CreateBucketRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createBucket>>,
  TError,
  { data: CreateBucketRequest },
  TContext
> => {
  const mutationOptions = getCreateBucketMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * 
Deletes a storage bucket. A bucket cannot be deleted if it is not empty.

**Warning:** this will delete all aliases associated with the bucket!
    
 */
export const deleteBucket = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/proxy/v2/DeleteBucket`,
    method: 'POST',
    signal,
  })
}

export const getDeleteBucketMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteBucket>>,
    TError,
    void,
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteBucket>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['deleteBucket']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteBucket>>,
    void
  > = () => {
    return deleteBucket()
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteBucketMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteBucket>>
>

export type DeleteBucketMutationError = ErrorType<void>

export const useDeleteBucket = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteBucket>>,
      TError,
      void,
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteBucket>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getDeleteBucketMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * 
Given a bucket identifier (`id`) or a global alias (`alias`), get its information.
It includes its aliases, its web configuration, keys that have some permissions
on it, some statistics (number of objects, size), number of dangling multipart uploads,
and its quotas (if any).
    
 */
export const getBucketInfo = (
  params?: GetBucketInfoParams,
  signal?: AbortSignal,
) => {
  return customInstance<GetBucketInfoResponse>({
    url: `/proxy/v2/GetBucketInfo`,
    method: 'GET',
    params,
    signal,
  })
}

export const getGetBucketInfoQueryKey = (params?: GetBucketInfoParams) => {
  return [`/proxy/v2/GetBucketInfo`, ...(params ? [params] : [])] as const
}

export const getGetBucketInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getBucketInfo>>,
  TError = ErrorType<void>,
>(
  params?: GetBucketInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBucketInfo>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetBucketInfoQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBucketInfo>>> = ({
    signal,
  }) => getBucketInfo(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBucketInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBucketInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBucketInfo>>
>
export type GetBucketInfoQueryError = ErrorType<void>

export function useGetBucketInfo<
  TData = Awaited<ReturnType<typeof getBucketInfo>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetBucketInfoParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBucketInfo>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBucketInfo>>,
          TError,
          Awaited<ReturnType<typeof getBucketInfo>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetBucketInfo<
  TData = Awaited<ReturnType<typeof getBucketInfo>>,
  TError = ErrorType<void>,
>(
  params?: GetBucketInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBucketInfo>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBucketInfo>>,
          TError,
          Awaited<ReturnType<typeof getBucketInfo>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetBucketInfo<
  TData = Awaited<ReturnType<typeof getBucketInfo>>,
  TError = ErrorType<void>,
>(
  params?: GetBucketInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBucketInfo>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useGetBucketInfo<
  TData = Awaited<ReturnType<typeof getBucketInfo>>,
  TError = ErrorType<void>,
>(
  params?: GetBucketInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBucketInfo>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetBucketInfoQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * 
Returns detailed information about an object in a bucket, including its internal state in Garage.

This API call can be used to list the data blocks referenced by an object,
as well as to view metadata associated to the object.

This call may return a list of more than one version for the object, for instance in the
case where there is a currently stored version of the object, and a newer version whose
upload is in progress and not yet finished.
    
 */
export const inspectObject = (
  params: InspectObjectParams,
  signal?: AbortSignal,
) => {
  return customInstance<InspectObjectResponse>({
    url: `/proxy/v2/InspectObject`,
    method: 'GET',
    params,
    signal,
  })
}

export const getInspectObjectQueryKey = (params: InspectObjectParams) => {
  return [`/proxy/v2/InspectObject`, ...(params ? [params] : [])] as const
}

export const getInspectObjectQueryOptions = <
  TData = Awaited<ReturnType<typeof inspectObject>>,
  TError = ErrorType<void>,
>(
  params: InspectObjectParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof inspectObject>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getInspectObjectQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof inspectObject>>> = ({
    signal,
  }) => inspectObject(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof inspectObject>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InspectObjectQueryResult = NonNullable<
  Awaited<ReturnType<typeof inspectObject>>
>
export type InspectObjectQueryError = ErrorType<void>

export function useInspectObject<
  TData = Awaited<ReturnType<typeof inspectObject>>,
  TError = ErrorType<void>,
>(
  params: InspectObjectParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof inspectObject>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inspectObject>>,
          TError,
          Awaited<ReturnType<typeof inspectObject>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useInspectObject<
  TData = Awaited<ReturnType<typeof inspectObject>>,
  TError = ErrorType<void>,
>(
  params: InspectObjectParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof inspectObject>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inspectObject>>,
          TError,
          Awaited<ReturnType<typeof inspectObject>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useInspectObject<
  TData = Awaited<ReturnType<typeof inspectObject>>,
  TError = ErrorType<void>,
>(
  params: InspectObjectParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof inspectObject>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useInspectObject<
  TData = Awaited<ReturnType<typeof inspectObject>>,
  TError = ErrorType<void>,
>(
  params: InspectObjectParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof inspectObject>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getInspectObjectQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * List all the buckets on the cluster with their UUID and their global and local aliases.
 */
export const listBuckets = (signal?: AbortSignal) => {
  return customInstance<ListBucketsResponse>({
    url: `/proxy/v2/ListBuckets`,
    method: 'GET',
    signal,
  })
}

export const getListBucketsQueryKey = () => {
  return [`/proxy/v2/ListBuckets`] as const
}

export const getListBucketsQueryOptions = <
  TData = Awaited<ReturnType<typeof listBuckets>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listBuckets>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListBucketsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listBuckets>>> = ({
    signal,
  }) => listBuckets(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listBuckets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBucketsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listBuckets>>
>
export type ListBucketsQueryError = ErrorType<void>

export function useListBuckets<
  TData = Awaited<ReturnType<typeof listBuckets>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBuckets>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBuckets>>,
          TError,
          Awaited<ReturnType<typeof listBuckets>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListBuckets<
  TData = Awaited<ReturnType<typeof listBuckets>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBuckets>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBuckets>>,
          TError,
          Awaited<ReturnType<typeof listBuckets>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListBuckets<
  TData = Awaited<ReturnType<typeof listBuckets>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBuckets>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useListBuckets<
  TData = Awaited<ReturnType<typeof listBuckets>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBuckets>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListBucketsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * 
All fields (`websiteAccess` and `quotas`) are optional.
If they are present, the corresponding modifications are applied to the bucket, otherwise nothing is changed.

In `websiteAccess`: if `enabled` is `true`, `indexDocument` must be specified.
The field `errorDocument` is optional, if no error document is set a generic
error message is displayed when errors happen. Conversely, if `enabled` is
`false`, neither `indexDocument` nor `errorDocument` must be specified.

In `quotas`: new values of `maxSize` and `maxObjects` must both be specified, or set to `null`
to remove the quotas. An absent value will be considered the same as a `null`. It is not possible
to change only one of the two quotas.
    
 */
export const updateBucket = (
  updateBucketRequestBody: UpdateBucketRequestBody,
  params: UpdateBucketParams,
  signal?: AbortSignal,
) => {
  return customInstance<GetBucketInfoResponse>({
    url: `/proxy/v2/UpdateBucket`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: updateBucketRequestBody,
    params,
    signal,
  })
}

export const getUpdateBucketMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBucket>>,
    TError,
    { data: UpdateBucketRequestBody; params: UpdateBucketParams },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateBucket>>,
  TError,
  { data: UpdateBucketRequestBody; params: UpdateBucketParams },
  TContext
> => {
  const mutationKey = ['updateBucket']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateBucket>>,
    { data: UpdateBucketRequestBody; params: UpdateBucketParams }
  > = (props) => {
    const { data, params } = props ?? {}

    return updateBucket(data, params)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateBucketMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateBucket>>
>
export type UpdateBucketMutationBody = UpdateBucketRequestBody
export type UpdateBucketMutationError = ErrorType<void>

export const useUpdateBucket = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateBucket>>,
      TError,
      { data: UpdateBucketRequestBody; params: UpdateBucketParams },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateBucket>>,
  TError,
  { data: UpdateBucketRequestBody; params: UpdateBucketParams },
  TContext
> => {
  const mutationOptions = getUpdateBucketMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
