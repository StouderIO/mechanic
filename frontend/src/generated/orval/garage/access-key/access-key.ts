/**
 * Generated by orval v7.10.0 ðŸº
 * Do not edit manually.
 * Garage administration API
 * Administrate your Garage cluster programatically, including status, layout, keys, buckets, and maintainance tasks.

*Disclaimer: This API may change in future Garage versions. Read the changelog and upgrade your scripts before upgrading. Additionnaly, this specification is early stage and can contain bugs, so be careful and please report any issues on our issue tracker.*
 * OpenAPI spec version: v2.0.0
 */

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'
import type { ErrorType } from '../../../../axios-instance'

import { customInstance } from '../../../../axios-instance'
import type {
  DeleteKeyParams,
  GetKeyInfoParams,
  GetKeyInfoResponse,
  ImportKeyRequest,
  ListKeysResponse,
  UpdateKeyRequestBody,
} from '../endpoints.schemas'

/**
 * Creates a new API access key.
 */
export const createKey = (
  updateKeyRequestBody: UpdateKeyRequestBody,
  signal?: AbortSignal,
) => {
  return customInstance<GetKeyInfoResponse>({
    url: `/proxy/v2/CreateKey`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: updateKeyRequestBody,
    signal,
  })
}

export const getCreateKeyMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createKey>>,
    TError,
    { data: UpdateKeyRequestBody },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createKey>>,
  TError,
  { data: UpdateKeyRequestBody },
  TContext
> => {
  const mutationKey = ['createKey']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createKey>>,
    { data: UpdateKeyRequestBody }
  > = (props) => {
    const { data } = props ?? {}

    return createKey(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof createKey>>
>
export type CreateKeyMutationBody = UpdateKeyRequestBody
export type CreateKeyMutationError = ErrorType<void>

export const useCreateKey = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createKey>>,
      TError,
      { data: UpdateKeyRequestBody },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createKey>>,
  TError,
  { data: UpdateKeyRequestBody },
  TContext
> => {
  const mutationOptions = getCreateKeyMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Delete a key from the cluster. Its access will be removed from all the buckets. Buckets are not automatically deleted and can be dangling. You should manually delete them before.
 */
export const deleteKey = (params: DeleteKeyParams, signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/proxy/v2/DeleteKey`,
    method: 'POST',
    params,
    signal,
  })
}

export const getDeleteKeyMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteKey>>,
    TError,
    { params: DeleteKeyParams },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteKey>>,
  TError,
  { params: DeleteKeyParams },
  TContext
> => {
  const mutationKey = ['deleteKey']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteKey>>,
    { params: DeleteKeyParams }
  > = (props) => {
    const { params } = props ?? {}

    return deleteKey(params)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteKey>>
>

export type DeleteKeyMutationError = ErrorType<void>

export const useDeleteKey = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteKey>>,
      TError,
      { params: DeleteKeyParams },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteKey>>,
  TError,
  { params: DeleteKeyParams },
  TContext
> => {
  const mutationOptions = getDeleteKeyMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * 
Return information about a specific key like its identifiers, its permissions and buckets on which it has permissions.
You can search by specifying the exact key identifier (`id`) or by specifying a pattern (`search`).

For confidentiality reasons, the secret key is not returned by default: you must pass the `showSecretKey` query parameter to get it.
    
 */
export const getKeyInfo = (params?: GetKeyInfoParams, signal?: AbortSignal) => {
  return customInstance<GetKeyInfoResponse>({
    url: `/proxy/v2/GetKeyInfo`,
    method: 'GET',
    params,
    signal,
  })
}

export const getGetKeyInfoQueryKey = (params?: GetKeyInfoParams) => {
  return [`/proxy/v2/GetKeyInfo`, ...(params ? [params] : [])] as const
}

export const getGetKeyInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getKeyInfo>>,
  TError = ErrorType<void>,
>(
  params?: GetKeyInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getKeyInfo>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetKeyInfoQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getKeyInfo>>> = ({
    signal,
  }) => getKeyInfo(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getKeyInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetKeyInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getKeyInfo>>
>
export type GetKeyInfoQueryError = ErrorType<void>

export function useGetKeyInfo<
  TData = Awaited<ReturnType<typeof getKeyInfo>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetKeyInfoParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getKeyInfo>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKeyInfo>>,
          TError,
          Awaited<ReturnType<typeof getKeyInfo>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetKeyInfo<
  TData = Awaited<ReturnType<typeof getKeyInfo>>,
  TError = ErrorType<void>,
>(
  params?: GetKeyInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getKeyInfo>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKeyInfo>>,
          TError,
          Awaited<ReturnType<typeof getKeyInfo>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetKeyInfo<
  TData = Awaited<ReturnType<typeof getKeyInfo>>,
  TError = ErrorType<void>,
>(
  params?: GetKeyInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getKeyInfo>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useGetKeyInfo<
  TData = Awaited<ReturnType<typeof getKeyInfo>>,
  TError = ErrorType<void>,
>(
  params?: GetKeyInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getKeyInfo>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetKeyInfoQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * 
Imports an existing API key. This feature must only be used for migrations and backup restore.

**Do not use it to generate custom key identifiers or you will break your Garage cluster.**
    
 */
export const importKey = (
  importKeyRequest: ImportKeyRequest,
  signal?: AbortSignal,
) => {
  return customInstance<GetKeyInfoResponse>({
    url: `/proxy/v2/ImportKey`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: importKeyRequest,
    signal,
  })
}

export const getImportKeyMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importKey>>,
    TError,
    { data: ImportKeyRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof importKey>>,
  TError,
  { data: ImportKeyRequest },
  TContext
> => {
  const mutationKey = ['importKey']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importKey>>,
    { data: ImportKeyRequest }
  > = (props) => {
    const { data } = props ?? {}

    return importKey(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type ImportKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof importKey>>
>
export type ImportKeyMutationBody = ImportKeyRequest
export type ImportKeyMutationError = ErrorType<void>

export const useImportKey = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof importKey>>,
      TError,
      { data: ImportKeyRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof importKey>>,
  TError,
  { data: ImportKeyRequest },
  TContext
> => {
  const mutationOptions = getImportKeyMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Returns all API access keys in the cluster.
 */
export const listKeys = (signal?: AbortSignal) => {
  return customInstance<ListKeysResponse>({
    url: `/proxy/v2/ListKeys`,
    method: 'GET',
    signal,
  })
}

export const getListKeysQueryKey = () => {
  return [`/proxy/v2/ListKeys`] as const
}

export const getListKeysQueryOptions = <
  TData = Awaited<ReturnType<typeof listKeys>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listKeys>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListKeysQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listKeys>>> = ({
    signal,
  }) => listKeys(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listKeys>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListKeysQueryResult = NonNullable<
  Awaited<ReturnType<typeof listKeys>>
>
export type ListKeysQueryError = ErrorType<void>

export function useListKeys<
  TData = Awaited<ReturnType<typeof listKeys>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listKeys>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listKeys>>,
          TError,
          Awaited<ReturnType<typeof listKeys>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListKeys<
  TData = Awaited<ReturnType<typeof listKeys>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listKeys>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listKeys>>,
          TError,
          Awaited<ReturnType<typeof listKeys>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListKeys<
  TData = Awaited<ReturnType<typeof listKeys>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listKeys>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useListKeys<
  TData = Awaited<ReturnType<typeof listKeys>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listKeys>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListKeysQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * 
Updates information about the specified API access key.

*Note: the secret key is not returned in the response, `null` is sent instead.*
    
 */
export const updateKey = (
  updateKeyRequestBody: UpdateKeyRequestBody,
  signal?: AbortSignal,
) => {
  return customInstance<GetKeyInfoResponse>({
    url: `/proxy/v2/UpdateKey`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: updateKeyRequestBody,
    signal,
  })
}

export const getUpdateKeyMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateKey>>,
    TError,
    { data: UpdateKeyRequestBody },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateKey>>,
  TError,
  { data: UpdateKeyRequestBody },
  TContext
> => {
  const mutationKey = ['updateKey']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateKey>>,
    { data: UpdateKeyRequestBody }
  > = (props) => {
    const { data } = props ?? {}

    return updateKey(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateKey>>
>
export type UpdateKeyMutationBody = UpdateKeyRequestBody
export type UpdateKeyMutationError = ErrorType<void>

export const useUpdateKey = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateKey>>,
      TError,
      { data: UpdateKeyRequestBody },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateKey>>,
  TError,
  { data: UpdateKeyRequestBody },
  TContext
> => {
  const mutationOptions = getUpdateKeyMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
